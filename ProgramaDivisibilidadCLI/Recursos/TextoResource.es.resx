<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ErrorNumerico" xml:space="preserve">
    <value>El divisor, la base y el número de coeficientes deben ser números enteros positivos.</value>
  </data>
  <data name="ErrorPrimo" xml:space="preserve">
    <value>El divisor y la base no son coprimos.
El calculo de reglas de coeficientes en este caso no será implementado.
Ejecute este programa con la opción -x o actívela en el diálogo para obtener una regla de otro tipo.</value>
  </data>
  <data name="HelpAyuda" xml:space="preserve">
    <value>Devuelve por salida un documento de ayuda más largo explicando la aplicación con más detalle.</value>
  </data>
  <data name="HelpAyudaCorta" xml:space="preserve">
    <value>Devuelve por salida un pequeño documento indicando como ejecutar esta aplicación.</value>
  </data>
  <data name="HelpDirecto" xml:space="preserve">
    <value>Lee la base, divisor y, opcionalmente la longitud de las reglas de coeficientes, como argumentos en lugar de preguntarlos en modo diálogo. Deben ser enteros de 64 bits válidos.</value>
  </data>
  <data name="HelpExtendido" xml:space="preserve">
    <value>Puede devolver reglas de tipos distintos, también devuelve por pantalla explicaciones sobre como se aplican. Ignora los demás flags, excepto -d.</value>
  </data>
  <data name="HelpJson" xml:space="preserve">
    <value>Las reglas de coeficientes se devolveran como un objeto JSON, se reflejarán los cambios causados por otros flags.</value>
  </data>
  <data name="HelpNombre" xml:space="preserve">
    <value>Le da un nombre a las reglas de coeficientes, incluido en la salida.</value>
  </data>
  <data name="HelpSaltar" xml:space="preserve">
    <value>Si no se usan otras opciones, salta el dialogo relacionado con el resto de opciones, no afecta a la salida.</value>
  </data>
  <data name="HelpTodos" xml:space="preserve">
    <value>Devuelve todas las reglas con valores absolutos menores al divisor elegido.</value>
  </data>
  <data name="MensajeSalidaVoluntaria" xml:space="preserve">
    <value>Se ha detectado el mensaje de salida, se ha detenido el programa.</value>
  </data>
  <data name="MensajeParametrosDirecto" xml:space="preserve">
    <value>Divisor: {0}, Base: {1}, Coeficientes: {2}.</value>
  </data>
  <data name="MensajeFinDirecto" xml:space="preserve">
    <value>Se ha calculado la regla.</value>
  </data>
  <data name="MensajeDialogoExtendido" xml:space="preserve">
    <value>Pulse &lt;&lt;s&gt;&gt; para obtener reglas de coeficientes u otra letra para otras reglas: </value>
  </data>
  <data name="MensajeDialogoJson" xml:space="preserve">
    <value>Pulse &lt;&lt;s&gt;&gt; para que la regla se escriba en un JSON, si la regla no va a ser pasada a un programa, pulse otra tecla: </value>
  </data>
  <data name="MensajeDialogoTodas" xml:space="preserve">
    <value>Pulse &lt;&lt;s&gt;&gt; para obtener todas las reglas derivadas de la original u otra letra obtener solo la menor: </value>
  </data>
  <data name="MensajeDialogoBase" xml:space="preserve">
    <value>Base de la regla: </value>
  </data>
  <data name="ErrorBase" xml:space="preserve">
    <value>La base debe ser un entero mayor que uno.</value>
  </data>
  <data name="ErrorDivisor" xml:space="preserve">
    <value>El divisor debe ser un entero no negativo.
Tenga en cuenta que los números divisibles entre un número negativo son divisibles entre su valor absoluto.</value>
  </data>
  <data name="ErrorDivisorCoprimo" xml:space="preserve">
    <value>El divisor debe ser un entero positivo mayor que uno y coprimo con la base.
Dos números son coprimos si su máximo común divisor es mayor que uno.</value>
  </data>
  <data name="MensajeDialogoDivisor" xml:space="preserve">
    <value>Divisor de la regla: </value>
  </data>
  <data name="MensajeDialogoCoeficientes" xml:space="preserve">
    <value>Número de coeficientes de la regla: </value>
  </data>
  <data name="ErrorCoeficientes" xml:space="preserve">
    <value>El número de coeficientes debe ser un entero positivo.</value>
  </data>
  <data name="MensajeInicioDialogo" xml:space="preserve">
    <value>Se pedirá que introduzca los datos por consola, escriba {0} para interrumpir el programa.</value>
  </data>
  <data name="MensajeDialogoRegla" xml:space="preserve">
    <value>Nombre de la regla, puede dejarse vacío: </value>
  </data>
  <data name="MensajeDialogoResultado" xml:space="preserve">
    <value>Regla obtenida: </value>
  </data>
  <data name="MensajeDialogoRepetir" xml:space="preserve">
    <value>Pulse &lt;&lt;s&gt;&gt; para calcular otra regla: </value>
  </data>
  <data name="MensajeDialogoInterrumpido" xml:space="preserve">
    <value>Se ha interrumpido el programa.</value>
  </data>
  <data name="SentenceBadFormatConversionErrorOption" xml:space="preserve">
    <value>Opción '{0}' está definida en un formato erróneo.</value>
  </data>
  <data name="SentenceBadFormatConversionErrorValue" xml:space="preserve">
    <value>Valor separado de una opción está definido en un formato erróneo.</value>
  </data>
  <data name="SentenceBadFormatTokenError" xml:space="preserve">
    <value>Elemento '{0}' no se reconoce.</value>
  </data>
  <data name="SentenceBadVerbSelectedError" xml:space="preserve">
    <value>Verbo '{0}' no se reconoce. (Este error no debería aparecer).</value>
  </data>
  <data name="SentenceErrorsHeadingText" xml:space="preserve">
    <value>ERROR(ES):</value>
  </data>
  <data name="SentenceHelpCommandTextOption" xml:space="preserve">
    <value>Mostrar esta pantalla de ayuda.</value>
  </data>
  <data name="SentenceHelpCommandTextVerb" xml:space="preserve">
    <value>Mostrar más ayuda de un comando en concreto.</value>
  </data>
  <data name="SentenceMissingRequiredOptionError" xml:space="preserve">
    <value>Opción obligatoria '{0}' no proporcionada.</value>
  </data>
  <data name="SentenceMissingRequiredValueError" xml:space="preserve">
    <value>Un valor no vinculado a un nombre de opción no se ha encontrado.</value>
  </data>
  <data name="SentenceMissingValueOptionError" xml:space="preserve">
    <value>Opción '{0}' no tiene valor.</value>
  </data>
  <data name="SentenceMutuallyExclusiveSetErrors" xml:space="preserve">
    <value>Opciones: {0} no son compatibles con {1}.</value>
  </data>
  <data name="SentenceNoVerbSelectedError" xml:space="preserve">
    <value>Ningún verbo seleccionado. (Este error no debería aparecer).</value>
  </data>
  <data name="SentenceRepeatedOptionError" xml:space="preserve">
    <value>Opción '{0}' definida varias veces.</value>
  </data>
  <data name="SentenceRequiredWord" xml:space="preserve">
    <value>Obligatorio.</value>
  </data>
  <data name="SentenceSequenceOutOfRangeErrorOption" xml:space="preserve">
    <value>Una opción de secuencia '{0}' se ha definido con menos elementos de los obligatorios.</value>
  </data>
  <data name="SentenceSequenceOutOfRangeErrorValue" xml:space="preserve">
    <value>Valor de una secuencia no vinculada a un nombre de opción tiene menos elementos de los obligatorios.</value>
  </data>
  <data name="SentenceSetValueExceptionError" xml:space="preserve">
    <value>Error cambiando valor para la opción '{0}': {1}</value>
  </data>
  <data name="SentenceUnknownOptionError" xml:space="preserve">
    <value>No se reconoce la opción '{0}'.</value>
  </data>
  <data name="SentenceUsageHeadingText" xml:space="preserve">
    <value>USO:</value>
  </data>
  <data name="SentenceVersionCommandText" xml:space="preserve">
    <value>Mostrar información de versión.</value>
  </data>
  <data name="OptionGroupWord" xml:space="preserve">
    <value>opción</value>
  </data>
  <data name="Ayuda" xml:space="preserve">
    <value>Ayuda de CalcDivCLI:

- Plantilla de uso: CalcDivCLI.exe [-&lt;nombre de opción corto&gt;|--&lt;nombre de opción largo&gt; [&lt;argumentos obligatorios ...&gt; [&lt;argumentos opcionales&gt;...]]

Ejemplo: *CalcDiv.exe --json --direct-output 7 10 --named-rule Nombre*
Equivalente a: *CalcDiv.exe -jd 7 10 -n Nombre*
Calcula la regla de 7 en base 10, le da el nombre Nombre y lo escribe en JSON.

- Opciones del programa, se concatenan sin el guion, por ejemplo: *CalcDiv.exe -ajd 3 4 1* o *CalcDiv.exe -H*, use --help para obtener más información.

-H: escribe este mensaje por pantalla, ignora las otras opciones.
-h: muestra una versión reducida de la ayuda, ignora las otras opciones.
-d: si se pasan todos los datos se obtiene un resultado sin que la aplicación pida datos.
-a: se escriben todas las reglas posibles con la cantidad de coeficientes proporcionado, el valor absoluto de los coeficientes será menor que el del divisor.
-n: escribe el nombre introducido como parámetro antes de cada elemento con su indice.
-j: escribe la regla como en JSON, a no ser que se use -x.
-x: cambia la salida a una regla alternativa que no usa coeficientes y explica como usarla. Los casos disponibles son como las reglas de 0, 1, 2, 3 y 11.

Todos los argumentos y opciones deben ser correctos.
Las opciones con argumentos no pueden ir seguidas de otras opciones en una combinación, por ejemplo: *CalcDiv.exe -na Nombre* sería una llamada inválida, pero la combinación -an Nombre es válida.

Este programa permite calcular reglas de divisibilidad de cualquier número natural positivo en cualquier base natural mayor que 1.
Las reglas se expresan normalmente como una lista de coeficientes, estos se multiplican por las cifras en la misma posición de un número y son sumados al resto de número al que se aplique.
La regla se aplica recursivamente hasta poder concluir si el número resultante es múltiplo del divisor.
El número de coeficientes se puede introducir como argumento si se usa -d, pero no con -x.

Por ejemplo, para la regla [-2,-3] con el divisor 7 en base 10, la usamos con 1234.

-Primero, multiplicamos 3 por -3 y 4 por -2, obteniendo -6 y -12.
-Después, le sumamos estos productos al resto del número, en este caso 12. El resultado es -6.

Trivialmente, -6 no es múltiplo de 7, por lo tanto 1234 tampoco lo es.
Si no es tan fácil ver si el resultado es múltiplo del divisor, se aplica la regla sobre el hasta llegar a una conclusión.

- Mensajes de salida

0: el programa se ha ejecutado de forma correcta.
1: no todos los datos introducidos fueron correctos.
2: se han introducido argumentos de forma errónea.
3: el usuario ha cerrado el programa de forma voluntaria.
4: se pidió una regla alternativa con -x, pero no se pudo encontrar.
</value>
  </data>
  <data name="AyudaCorta" xml:space="preserve">
    <value>- Plantilla de uso: CalcDivCLI.exe [-&lt;nombre de opción corto&gt;|--&lt;nombre de opción largo&gt; [&lt;argumentos obligatorios ...&gt; [&lt;argumentos opcionales&gt;...]]

Ejemplo: *CalcDiv.exe --json --direct-output 7 10 --named-rule Nombre*
Equivalente a: *CalcDiv.exe -jd 7 10 -n Nombre*
Calcula la regla de 7 en base 10, le da el nombre Nombre y lo escribe en JSON.

Use --help para ver información de las opciones y argumentos o -H para ver más información sobre la aplicación.</value>
  </data>
  <data name="DirectoReferirExtendidoPotencias" xml:space="preserve">
    <value>No se puede calcular una regla de coeficientes, el divisor está compuesto de los factores primos de la base, para obtener una regla en este caso ejecute con la opción -x, por ejemplo: </value>
  </data>
  <data name="DirectoReferirExtendidoErrorInesperado" xml:space="preserve">
    <value>No se puede calcular una regla de coeficientes debido a un error inesperado, pruebe a ejecutar con la opción -x, por ejemplo: </value>
  </data>
  <data name="DirectoReferirExtendidoUsable" xml:space="preserve">
    <value>Se puede calcular una regla de coeficientes, pero en estos casos se recomienda ejecutar con la opción -x, por ejemplo: </value>
  </data>
  <data name="DirectoReferirExtendidoValido" xml:space="preserve">
    <value>Se puede calcular la regla de coeficientes, en este caso no se recomienda usar la opción -x.</value>
  </data>
  <data name="DialogoExcepcionInesperada" xml:space="preserve">
    <value>Ha ocurrido un error inesperado, considere crear un Issue en GitHub si no existe, incluya la traza de error de arrbia y los argumentos del programa:
https://github.com/JosePrietoPaez/CalcDiv/issues</value>
  </data>
  <data name="HelpVarias" xml:space="preserve">
    <value>Recibe varias bases, divisores y coeficientes como argumentos y devuelve la regla de cada tupla (divisor, base, coeficiente).
Todas las bases, divisores y coeficientes deben ser válidos.
Activa el modo directo.</value>
  </data>
  <data name="ErrorPrimoExtra" xml:space="preserve">
    <value>El divisor y la base no son coprimos.
El calculo de reglas de coeficientes en este caso no sera implementado.</value>
  </data>
</root>